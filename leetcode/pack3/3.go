package main

func canFinish(n int, pre [][]int) bool {
	// Создаем таблицу смежности, представляющую граф.
	table := make(map[int][]int, n)
	for i := 0; i < len(pre); i++ {
		if len(pre[i]) == 2 {
			// Добавляем ребро из pre[i][0] в pre[i][1]
			table[pre[i][0]] = append(table[pre[i][0]], pre[i][1])
		}
	}

	// Создаем массив для отслеживания состояния посещения узлов:
	// 0 - узел не посещен,
	// 1 - узел находится в текущем стеке вызовов (в процессе посещения),
	// -1 - узел посещен и проверен.
	vis := make([]int, n)

	// Флаг для отслеживания наличия цикла в графе.
	flag := true

	// Определяем функцию для проверки циклов в графе.
	var checkCycle func(key int)
	checkCycle = func(key int) {
		// Если узел уже находится в текущем стеке вызовов, обнаружен цикл.
		if vis[key] == 1 {
			flag = false
			return
		}
		// Если узел уже проверен, пропускаем его.
		if vis[key] == -1 {
			return
		}

		// Отмечаем узел как находящийся в текущем стеке вызовов.
		vis[key] = 1
		// Рекурсивно проверяем всех соседей текущего узла.
		for _, v := range table[key] {
			checkCycle(v)
		}

		// Отмечаем узел как проверенный.
		vis[key] = -1
		return
	}

	// Проверяем все ключи в таблице на наличие циклов.
	for key := range table {
		checkCycle(key)
	}

	// Возвращаем true, если циклов не обнаружено, иначе false.
	return flag
}
